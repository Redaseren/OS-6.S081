1. inline 内联函数
	内联函数在可读性方面与函数是相同的，而在编译时是将函数直接嵌入调用程序的主体，省去了调用/返回指令，这样在运行时速度更快。
	内联函数可以调试，而宏定义是不可以调试的。　内联函数是代码被插入到调用者代码处的函数。如同 #define 宏（但并不等同，原因见下文），内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（“过程化集成”）被编译器优化。
　和 #define 宏不同的是，内联函数总是对参数只精确地进行一次求值，从而避免了那声名狼藉的宏错误。换句话说，调用内联函数和调用正规函数是等价的，差别仅仅是更快。
	栈空间就是指放置程式的局部数据也就是函数内数据的内存空间，在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足所造成的程式出错的问题，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。



2. UInt64 无符号整型，范围 [0 : 18446744073709551615]
	固定长度的整型，包括有符号整型或无符号整型

3. asm
	内嵌汇编标识为asm()。asm是c/c++中的内嵌汇编关键字，或称模板。用于通知编译器，接下来的()内的代码是内嵌汇编程序， 需要特殊处理。()内部的有自己专门的语法格式。内嵌汇编实现了c/c++语言和汇编语言的混合编程。比如你可以在一个c语言文件中使用MIPS汇编指令MOVE完成两个数/地址的拷贝：
	 asm("move %0,%1\n\t" :"=r"(ret) :"r"(src) );


4. volatile
	
	volatile是一个类型修饰符（type specifier）。它是被设计用来修饰被不同线程访问和修改的变量。如果没有volatile，基本上会导致这样的结果：要么无法编写多线程程序，要么编译器失去大量优化的机会。
	volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。
	如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）

5. << 与>>
	<< : 左移就是把一个数的所有位都向左移动若干位,在C中用<<运算符
	>> :右移


6.重定向：  
 	输入重定向: '<' 符号是Unix、Linux和DOS的重定向运算符
	输出重定向：'>'
